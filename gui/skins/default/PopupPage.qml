/*
 * Copyright Â© 2011-2013 BTicino S.p.A.
 *
 * This file is part of BtExperience.
 *
 * BtExperience is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BtExperience is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with BtExperience. If not, see <http://www.gnu.org/licenses/>.
 */

import QtQuick 1.1
import BtObjects 1.0
import Components 1.0
import Components.Popup 1.0
import BtExperience 1.0
import "js/Stack.js" as Stack
import "js/datetime.js" as DateTime
import "js/popup.js" as PopupLogic
import "js/navigation.js" as Navigation


/**
  \ingroup Core

  \brief Component for a page showing popups.

  This component implements a page to show popups.
  Some popups live entirely inside a page. These are called page popups and
  they are implemented in BasePage.
  Other popups are independent of any page. These are called application
  popups and they are implemented here.
  For example, a popup informing the user that a burglar alarm has triggered
  is an application popup.
  An application popup must appear as soon as the related event triggers.
  The events are generally asynchronous, i.e. they are generated by the C++
  model, they are not triggered by user interaction.
  These events are collected and managed inside the EventManager component that
  contains the QML logic behind these events.
  The graphical part of these asynchronous events is managed here.

  The page uses the ControlPopup component to show the popup details.
  It uses the standard popup management code present in BasePage for page popups.
  It contains several methods to manage all possible popup kinds.
  Internally, popups are ordered by priority (based on popup type) and then
  by chronological arrival order.

  The page contains logic to show the next priority order popup when the
  current one is closed. When a new popup arrives, the programmer must check
  if a PopupPage already exists on the stack and use that. If the PopupPage
  doesn't exist yet, it must be created and placed on the right position on
  the stack. See EventManager for the logic related to the popup management.
  */
BasePage {
    id: page

    opacity: 0
    _pageName: "PopupPage"

    onPopupDismissed: privateProps.scenarioPopupClosed()

    Component {
        id: generalPopupComponent
        ControlPopup {
            id: popupControl

            onDismissClicked: privateProps.update(PopupLogic.dismiss())
            onConfirmClicked: privateProps.navigate(PopupLogic.confirm())
        }
    }

    Component {
        id: scenarioPopupComponent
        FeedbackPopup {
            isOk: true
        }
    }

    Behavior on opacity {
        NumberAnimation { duration: constants.alertTransitionDuration }
    }

    // used to pre-load energy graph values
    EnergyGraphObject {
        id: energyGraphCache
        measureType: EnergyData.Consumption
    }

    /**
      Updates the unread messages popup with the right number of unread messages.
      When a message arrives, only the number of unread messages is shown.
      If the popup already exists, updates the existing popup instead of
      creating a new one.
      @param type:int unreadMessages The number of unread messages (must be greater than zero)
      */
    function updateUnreadMessages(unreadMessages) {
        privateProps.update(PopupLogic.updateUnreadMessages(unreadMessages))
    }

    /**
      Adds a new burglar alarm popup.
      When a new burglar alarm arrives, a new record is added to the list of
      burglar alarm popups. The popup always shows the highest priority popup.
      @param type:AlarmType type The alarm code
      @param type:AntintrusionAlarmSource zone The zone originating the alarm
      @param type:int number The zone number
      @param type:QDateTime dateTime The date and time the alarm triggered
      */
    function addAlarmPopup(type, zone, number, dateTime) {
        var dt = DateTime.format(dateTime)["time"] + " - " + DateTime.format(dateTime)["date"]

        var t = privateProps.antintrusionNames.get('ALARM_TYPE', type)

        var z = ""
        // computes zone description
        if (type === AntintrusionAlarm.Technical)
            z = zone.name
        else if (number >= 1 && number <= 8 && zone !== null)
            z = qsTr("zone") + " " + zone.name
        else
            z = qsTr("zone") + " " + number

        privateProps.update(PopupLogic.addAlarmPopup(t, z, dt))

        // rings the bell
        global.ringtoneManager.playRingtone(global.ringtoneManager.ringtoneFromType(RingtoneManager.Alarm), AudioState.Ringtone)
    }

    /**
      Adds a new stop and go popup
      @param type:StopAndGo device The stop and go device that triggered the alert
      */
    function addStopAndGoPopup(device) {
        // status description
        var t = privateProps.energyManagementNames.get('STOP_GO_STATUS', device.status)

        privateProps.update(PopupLogic.addStopAndGoPopup(device.name, t))

        // rings the bell
        global.ringtoneManager.playRingtone(global.ringtoneManager.ringtoneFromType(RingtoneManager.Alarm), AudioState.Ringtone)
    }

    /**
      Adds a popup showing a scenario activation popup
      @param type:string description The scenario description
      */
    function addScenarioActivationPopup(description) {
        privateProps.update(PopupLogic.addScenarioActivationPopup(description))
    }

    /**
      Adds a goal reached popup
      @param type:EnergyDevice energyDevice The energy device that reached the goal
      */
    function addGoalReachedPopup(energyDevice) {
        privateProps.update(PopupLogic.addGoalReachedPopup(energyDevice))
    }

    /**
      Adds a monthly report popup.
      Every first day of month a report is generated about the plant.
      This popup shows a messages informing the user the report is ready.
      */
    function addMonthlyReportNotification() {
        privateProps.update(PopupLogic.addMonthlyReportNotification())
    }

    /**
      Adds an alarm clock trigger popup.
      When an alarm clock triggers, a popup is generated.
      The popup can stop the alarm or snooze it a bit.
      @param type:AlarmClock device The ringing alarm clock
      */
    function addAlarmClockTriggering(device) {
        privateProps.update(PopupLogic.addAlarmClockPopup(device))
        device.ringingChanged.connect(removeAlarmClockPopup)
    }

    /**
      Removes the alarm clock popup when the alarm stops ringing.
      An alarm clock rings for an interval of time.
      If the interval elapses without user intervention, the alarm stops
      ringing. At that point this method is called to hide the alarm clock popup
      */
    function removeAlarmClockPopup() {
        privateProps.update(PopupLogic.removeAlarmClockPopup())
    }

    // needed to translate antintrusion names in alarm popups
    QtObject {
        id: privateProps

        property QtObject antintrusionNames: AntintrusionNames {}
        property QtObject energyManagementNames: EnergyManagementNames {}

        property variant alarmClock

        function scenarioPopupClosed() {
            var p = PopupLogic.highestPriorityPopup()
            if (p["_kind"] === "scenario")
                privateProps.update(PopupLogic.dismiss())
        }

        function navigate(data) {
            if (data === "") {
                // no navigation data, simply closes the popup page
                closePopup()
                return
            }

            if (data === "Antintrusion") {
                Stack.goToPage("Antintrusion.qml", {navigationTarget: Navigation.ALARM_LOG})
            }

            if (data === "Supervision") {
                Stack.goToPage("EnergyManagement.qml", {navigationTarget: Navigation.SUPERVISION})
            }

            if (data === "Messages") {
                Stack.goToPage("Messages.qml")
            }

            if (data === "GlobalView") {
                Stack.goToPage("EnergyGlobalView.qml")
            }

            if (data[0] === "GoalReached") {
                Stack.pushPageBelow("EnergyDataGraph.qml", {energyData: data[1]})
                closePopup()
                return
            }
        }

        function update(data) {
            if (data === undefined) {
                // no data to show, we can pop the page
                closePopup()
                return
            }

            if (data["_kind"] === "scenario") {
                // we may be here more if the user presses very quickly on
                // scenario activation; if a popup is already present don't do
                // anything and wait for the popup loop
                if (popupLoader.item === null) {
                    installPopup(scenarioPopupComponent)
                    popupLoader.item.text = data.line1
                }
            }
            else {
                installPopup(generalPopupComponent)

                popupLoader.item.title = data.title
                popupLoader.item.line1 = data.line1
                popupLoader.item.line2 = data.line2
                popupLoader.item.line3 = data.line3
                popupLoader.item.confirmText = data.confirmText
                popupLoader.item.dismissText = data.dismissText
            }

            if (data["_kind"] === "goal_reached") {
                energyGraphCache.energyData = data["_device"]
                energyGraphCache.graphType = EnergyData.CumulativeMonthGraph
                energyGraphCache.date = new Date()
            }

            if (page.opacity < 1)
                page.opacity = 1
        }

        function closePopup() {
            Stack.popPage()
        }
    }
}
